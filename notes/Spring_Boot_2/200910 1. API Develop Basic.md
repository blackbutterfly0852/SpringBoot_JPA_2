## 200910 API 개발 기본
### 1. 회원 등록 API
##### 1) 템플릿 엔진 랜더링 하는 컨트롤러와, API를 위한 컨트롤러를 분리

##### 2) saveMemberV1 문제
* 엔티티에 프레젠테이션 계층을 위한 로직이 추가된다.
* 엔티티에 API 검증을 위한 로직이 들어간다. (@NotEmpty 등등)
* 즉,어떤 API에서는 @NotEmpty 필요할 수 도 있고, 어떤 API에서는 @NotEmpty 필요하지 않을 수 있다.
* 실무에서는 회원 엔티티를 위한 API가 다양하게 만들어지는데, 한 엔티티에 각각의 API를 위한 모든 요청 요구사항을 담기는 어렵다.
* 엔티티가 변경되면 API 스펙이 변한다.
* 예를 들어 엔티티에서 name -> userName으로 변경 시 API 스펙이 변경됨, 클라이언트는 기존과 동일하게 API를 호출하지만 작동X
* 엔티티는 변경될 가능성이 높기 때문에, JSON을 바인딩해서 엔티티에 넣지 말고, 엔티티를 파라미터로 받지말고, 엔티티를 외부로 노출하면 안된다.

##### 3) saveMemberV2(saveMemberV1의 대안)
* API 요청 스펙에 맞추어 별도의 DTO를 파라미터로 받는다.
* 예를 들어 'API 스펙자체가 name만 받게 되는구나' -> 유지보수 큰 장점

### 2. 회원 수정 API
1) PUT -> RESTAPI 참조
2) updateMemberV2() : 커맨드와 쿼리를 분리해라

### 3. 회원 조회 API
##### 1) membersV1 문제점
* 기본적으로 엔티티의 모든 값이 노출된다. : 회원 조회인데, 회원의 주문내역까지 전달 
* 해결책 : Member.java : @JsonIgnore // 회원조회 API 시 주문내역을 제외하기 위한 API
* 그러나 위의 해결책은 다른 API 만들 때 다른 문제가 발생한다. 
* 실무에서는 같은 엔티티에 대해 API가 용도에 따라 다양하게 만들어지는데, 한 엔티티에 각각의 API를 위한 프레젠테이션 응답 로직을 담기는 어렵다.
* 예를 들어 어디는 주문내역을 필요하고, 어디는 주문내역이 필요없고.
* 즉 엔티티에 프레젠테이션 계층을 위한 로직이 추가된다. -> 양뱡향 의존관계로, 유지보수성이 좋지 않다.
* 엔티티 변경 시, API 스펙이 변경된다.
* 추가로 컬렉션을 직접 반환하면 항후 API 스펙을 변경하기 어렵다.(별도의 Result 클래스 생성으로 해결) 

##### 2) membersV2(membersV1의 대안)
* API 응답 스펙에 맞추어 별도의 DTO를 반환한다.

