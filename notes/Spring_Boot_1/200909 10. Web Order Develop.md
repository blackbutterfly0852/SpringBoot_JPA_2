## 200909 웹 계층 주문 개발
### 1. 연속성 엔티티와 준영속 엔티티
##### 1) 연속성 엔티티 : JPA가 관리하는 엔티티 -> commit -> flush(변경내역감지, dirty checking) -> update
* Order.java -> cancel()
##### 2) 준영속 엔티티 : JPA가 관리하지 않는 엔티티(영속성 컨테스트가 더 이상 관려하지 않은 엔티티) 
* ItemController.java -> updateItem()
* Book()을 생성 후 setId()를 해준다 -> 이미 이전에 DB에 들어간 데이터 -> 준영속 엔티티라 변경감지 X

### 2. 변경 감지(DirtyChecking) vs 병합(Merge)
##### 1) ItemService.java -> updateItem(itemId, book); 
* 트랜잭션 안에서 itemId를 통해 book 객체를 가져온다 -> 영속상태를 만들고, 변경 내역을 set한다 -> 트랜잭션 커밋 시점에 변경 감지
##### 2) 사실 이 방법은 병합이 작동하는 메커니즘과 동일하다.
##### 3) 병합은 준영속 상태 엔티티를 파라미터로 받아, 영속상태를 만들고 변경 내역을 set한다.  -> 트랜잭션 커밋 시점에 변경 감지
##### 4) 단 병합은 만약 값이 없으면 null로 업데이트 :  예를들어, Book의 가격은 한 번 결정되면 수정을 못한다 -> Book.price는 null로 업데이트
##### 5) 변경 감지는 원하는 속성만 변경, 병합은 모든 속성이 변경
##### 6) 실무에서는 변경감지로 원하는 속성만 UPDATE 진행해야한다.

### 3. 설계 시 주의점
##### 1)  업데이트는 SET 보다는 의미있는 메소드로 진행
* Controller -> Service -> Entity
* 이는, 추적이 가능하도록 설계하기 위함이다.
##### 2) Controller에서는 어설프게 엔티티 생성 X
##### 3) 트랜잭션이 있는 서비스 계층에 식별자와 변경(id) 데이터를 명확하게 전달.(파마미터, dto)
##### 4) 트랜잭션이 있는 서비스 계층에서 영속상태 엔티티 조회하고 엔티티의 데이터를 직접 변경.
##### 5) 트랜잭션 커밋시점에 변경 감지가 실행된다.
##### 6) 주문 같은 비즈니스 로직이 들어가는 경우는 Controller에서 Service로 파라미터 넘기고, Service에서 진행(영속성 컨테스트를 위해)