## 200904~05 주문 도메인 개발
### 1. 
##### 1) 상품 주문 - 재고관리
##### 2) 주문 조회
##### 3) 주문 취소 - 재고관리

### 2. 개발 순서
##### 1) 주문 엔티티, 주문 상품 엔티티 추가 개발
* 비즈니스 로직 추가
##### 2) 주문 리포지토리 개발
##### 3) 주문 서비스 개발
##### 4) 주문 검색 기능 개발
##### 5) 주문 기능 테스트

### 3. Order.java
##### 1) createOrder(생성메서드) createOrderItem(OrderItem.java, 생성메서드)
* 주문 생성 시점에 한 번에 정리, 추후에 이 부분만 수정하면됨
* 밖에서 SET방식이 아니라, 주문시 생성 메서드를 무조건 호출하여 파라미터로 넣어줌
* createOrderItem에서 먼저 OrderItem을 생성 후 createOrder의 파라미터로 넘어온다. (사용자 입장에서 생각해봐라)
* 복잡한 비즈니스 로직을 응집해 놓음.
##### 2) cancel()(비즈니스메소드)
* 비즈니스에 따른 체크로직이 엔티티 내부에 있다!
* OrderItem의 cancel() 메소드와 연결
##### 3) getTotalPrice(비즈니스메소드)
* OrderItem의 getTotalPrice() 메소드와 연결

### 4. 주문 레포지토리 개발
##### 1) 주문 저장
##### 2) 주문 단건 조회
##### 3) 동적 쿼리 -> 추후

### 5. 주문 서비스 개발
##### 0)
* 도메인 모델 패턴 : 서비스 계층은 단순히 엔티티에 필요한 요청을 위임하는 역할, 엔티티가 비즈니스 로직 처리
* 트랜잭션 스크립트 패턴 : 서비스 계층에서 대부분 비즈니스 로직 처리
* 위 두개는 상황에 맞게 사용
##### 1) 주문 
* 사용자 입장에서 생각 : 주문_ID, 상품_ID(한 개만 구매하도록), 수량을 선택에서 주문한다.
* orderItem과 Item의 생성 메서드 : Protected
* Cascade 조건 : private owner, Persist 라이프 사이클 동일
##### 2) 주문 취소 
*  Dirty Check, 변경내역 감지, 업데이트 쿼리 자동 생성
##### 3) 주문 검색 -> 추후

### 6. 주문 기능 테스트
##### 1) C+S+T OrderService.java OrderServiceTest.java 번갈아 이동 가능
##### 2) 테스트
* 주문 생성 테스트
* 상품주문_재고수량초과 테스트
* 주문 취소 테스트

### 7. 주문 검색 기능 개발
##### 1) JPA에서 동적쿼리는?
* 회원 이름과, 주문 상태(ORDER, CANCEL)가 모두 있는 경우 -> 둘 중에 하나만 있는 경우, 둘 다 없는 경우 고려 X -> 동적 쿼리 필요
* 동적 쿼리 방법 1 -> 무식한 방법, 실무 X, 버그 생성 가능성 높음
* 동적 쿼리 방법 2 -> JPA Criteria -> 실무 X , 단점 : 쿼리가 그려지지 않는다. 유지보수성 낮아짐
* QueryDSL 활용
* 실무 프로젝트 시 : SpringBoot, Spring JPA, QueryDSL