##200830 도메인 분석 설계 1/2
### 0. 용어
##### 1) 도메인 : 소프트웨어로 해결하고자 하는 문제영역,  소프트웨어를 개발하는 대상 영역
    https://javacan.tistory.com/entry/what-is-a-domain-model
##### 2) 도메인 모델 : 도메인을 모든 사람이 동일한 관점에서 이해할 수 있고 공유할 수 있도록 단순화
* 객체지향 프로그래밍을 하는 경우에는 일반적으로 클래스 다이어그램의 표기법을 사용
* 도메인 모델이라고 하면 정적 데이터 요소를 표현하는 것으로 국한하는 것 같은데 동적인 요소(예를 들어 유즈 케이스)까지 고려
##### 3) 모듈 : https://m.blog.naver.com/PostView.nhn?blogId=knix008&logNo=220698639553&proxyReferer=https:%2F%2Fwww.google.com%2F
* 독립적으로 재활용할 수 있는 소프트웨어 덩어리
* 모듈화 : 잘 정의된 인터페이스외의 자신의 내부구조에 대한 직접적인 접근을 제한하며, 다른 환경으로 포팅시 특정 인터페이스에만 의존한다
* 모듈은 독립적인 테스트 가능하며, 다른 모듈에 대한 의존성을 최소화
* 정의된 인터페이스을 충실히 따른 다른 모듈로도 대체가 가능하다.
* 계층적인 소프트웨어를 구성할 때, 한 계층의 부분을 차지하는 단위가 된다.
* 계층화를 통해 제공해야할 인터페이스와 자신이 의존하고 있는 인터페이스를 명확히 구분 필요
######-> 상위 계층에 제공하는 인터페이스, 실제 자신이 담당하고 있는 역할을 처리하는 부분, 제공되는 인터페이스를 사용하기 위한 의존성을 가지는 부분
* 모듈은 잘 정의된 하나의 역할만 가져야 된다.
* 모듈의 전역적인 자료구조에 대한 사용을 가능한 줄여야 하며, 그러한 자료구조에 대한 접근 방법도 모듈에서 제공하는 인터페이스만 사용
* 모듈이 외부로 공개하는 인터페이스들은 구조를 표현하는 것이 아니라, 요청을 받아들이는 창구역할을 해야된다.
######-> 즉 창구에서 받은 요청을 내부의 자료구조와 함수들을 이용해서 처리한 후 결과만 리턴해야한다.
* 모듈을 제대로 만들기만 해도, 대부분의 구조적인 문제를 해결되었다고 볼 수 있다.
##### 4) 컴포넌트 
* 독립적인 단위 모듈, 컴포넌트는 각각 독립된 모듈
* 컴포넌트 개념을 잘 적용한 소프트웨어란 부품(인터페이스를 구현받은 클래스)만 바꾸어 주었을시, 오류 없이 잘 작동 되는것


### 1. 요구사항
##### 1) 회원 : 가입, 회원목록 조회
##### 2) 상품 : 등록, 상품목록 조회
##### 3) 주문 : 주문, 주문 목록 조회, 주문 취소
##### 4) 기타 
* 재고관리 필요
* 상품은 도서, 음반, 영화가 있고 카테고리로 구분된다
* 주문시 배송지 입력이 가능하다.

### 2. 도메인 모델과 테이블 설계
##### 1) IE 표기법 
    https://dbguide.tistory.com/entry/%EB%AA%A8%EB%8D%B8%EB%A7%81-IE-%ED%91%9C%EA%B8%B0%EB%B2%95
##### 2) 외발과 까치발 / Identifying(실선) 과 non-Identifying(점선) -> 생사주기 / mandatory 과 optional
##### 3) 설계단계에서는 단방향 연관관계 추천 

### 3. 다 : 다 (Categories : Item)
##### 1) RDB : 1 : 다 , 다 : 1 풀어야 한다.
##### 2) 엔티티 : @ManyToMany 

### 4. Member와 Orders 
##### 1) 개발자 생각 : 회원이 주문을 하니까 회원에 Orders : List -> 비즈니스상 우위에 있다고 주인으로 정하면 안된다.
##### 2) 컴퓨터 생각 : 회원과 주문을 동급, 주문을 할 때 회원이 필요하다 (쿼리시에도 필터링 조건에 Member가 들어감)
##### 3) 결과적으로  Member의 Orders : List는 필요없다.

### 5. (1:다, 다:1), (1:1) 양방향 관계이면 연관관계 주인 정해야 한다.
##### 0) 연관관계 : Order의 mebmer 변수와, Members의 orders 변수가 서로 연관되있다.
##### 1) FK가 있는 '다'쪽이 연관관계 주인이다.(주인쪽에 값을 세팅해야 수정된다(?))
##### 2) '1' 은 연관관계 거울이다.(단순 조회용)

### 6. Item : 싱글테이블 전략, Dtype으로 구분(Flag)

### 7. 단방향 연관관계 (OrderItem -> Item)
##### 1) OrderItem은 Item 참조값을 가지고 있지만, Item은 OrderItem의 참조값을 가지고 있지 않다.

### 8. RDB 모델
##### 1) MEMBER와 ORDERS : 일대다, 생사주기 같이 X, 그림상 MEMBER쪽은 의무 ORDERS쪽이 비의무
##### 2) ORDERS와 ITEM은 다대다 관계
* ORDERS와 ORDER_ITEM : 일대다, 생사주기 같이 X, 그림상 둘다 의무
* ORDER_ITEM 과 ITEM : 다대일, 생사주기 같이 X, 그림상 ORDER_ITEM의 비의무
* 생사주기를 같이 않하기 때문에(점선), ORDER_ITEM에는 FK 2개 존재.
* 만약 그림상 '일'쪽이 비의무라면 FK는 null 값이 들어올수 있다.  
##### 3) ITEM과 CATEGORY는 다대다 관계
* ITEM과 CATEGORY_ITEM은 일대다 관계, 그림상 ITEM쪽은 의무, CATEGORY_ITEM은 비의무
* CATEGORY_ITEM과 CATEGORY는 다대일 관계, 그림상 CATEGORY_ITEM은 비의무, CATEGORY는 의무
* 생사주기를 같이하므로(실선), CATEGORY_ITEM에는 FK 2개가 복합 PK.
* 하나의 카테고리에는 여러개의 아이템을 가질 수 있다. : CATEGOY_ID(PK) - CATEGORY_ID(FK) - ITEM_ID(FK) * 여러개
* 하나의 아이템은 여러개의 카테고리에 속할 수 있다.   : ITEM_ID(PK) - ITEM(FK) - CATEGORY_ID(FK) * 여러개 
